#DTI Bot w/ take profit

trading = require 'trading'
talib = require 'talib'
params = require 'params'

DATA_INPUT = params.addOptions 'Data input', ['Close', 'Typical', 'Weighted', 'Heikin-Ashi'], 'Close'
TRADE_STYLE = params.addOptions 'Trading Style', ['Scalping', 'Mid-Range', 'Long-Term'], 'Mid-Range'
TAKE_PCT = params.add "Take Profit % (0 Disables)", 15
PCT_OF_FUNDS = params.add "Percent of funds to use for orders", 100
PCT_OF_SPLIT = params.add "Percent iceberg split", 25
MINIMUM_ORDER_VALUE = params.add "Minimum order value (exchange threshold)", .001

#instrument algos
makeInstrument = (instrument) ->
	switch DATA_INPUT
		when 'Typical'
			instrument.close = talib.TYPPRICE
				high: instrument.high
				low: instrument.low
				close: instrument.close
				startIdx: 0
				endIdx: instrument.close.length-1
		when 'Weighted'
			instrument.close = talib.WCLPRICE
				high: instrument.high
				low: instrument.low
				close: instrument.close
				startIdx: 0
				endIdx: instrument.close.length-1
		when 'Heikin-Ashi'
			close = talib.AVGPRICE
				open: instrument.open
				high: instrument.high
				low: instrument.low
				close: instrument.close
				startIdx: 0
				endIdx: instrument.close.length-1
			open = []
			prev = (instrument.close[0] + instrument.open[0]) / 2
			for x in [0..instrument.close.length-2]
				open[x] = (close[x] + prev) / 2
				prev = open[x]
			close = _.drop(close, 1)
			high = []
			low = []
			for x in [1..instrument.close.length-1]
				high[x-1] = Math.max(instrument.high[x], open[x-1], close[x-1])
				low[x-1] = Math.min(instrument.low[x], open[x-1], close[x-1])
			instrument.close = close
			instrument.open = open
			instrument.high = high
			instrument.low = low
			instrument.volumes = _.drop(instrument.volumes, 1)
	return instrument

#initialize plot marks
init: (context) ->

    info "Thanks for using the DTI BOT"
    info "Please be patient while the bot waits for a signal.."

    setPlotOptions
        BOUGHT:
            color: 'rgb(46, 204, 113)'
        SOLD:
            color: 'rgb(231, 76, 60)'
        "TAKE PROFIT":
            color: 'rgb(255, 224, 0)'
        "PRICE LINE":
            color: 'green'
            secondary: true
            size: 5
        "TRADE LINE":
            color: 'red'
            secondary: true
            size: 5
        "TOP V-BAND":
            color: 'black'
            secondary: true
            size: 5 
        "BOTTOM V-BAND":
            color: 'black'
            secondary: true
            size: 5            
        "MID V-BAND":
            color: 'orange'
            secondary: true
            size: 5 
        bulls:
            color: 'rgba(39, 174, 96, .25)'
            secondary: true
            size: 5

handle: (context, data) ->
    storage.consecutiveSellSignals ?= 0
    storage.consecutiveBuySignals ?= 0
    storage.wins ?= 0
    storage.losses ?= 0
    storage.sells ?= 0
    storage.sold ?= false
    storage.lastSellPrice ?= null
    storage.buys ?= 0
    storage.bought ?= false
    storage.lastBuyPrice ?= null
    storage.lastValue ?= null
    storage.lastFisher ?= null
    i = data.instruments[0]
    startCurrency = @portfolio.positions[i.curr()].amount
    startAssets = @portfolio.positions[i.asset()].amount
    longPeriod = Math.min(parseInt((24*60)/i.interval) * NUMBER_OF_DAYS, i.size - 1)
    shortPeriod = parseInt(longPeriod/3)

    currentPrice = _.last(i.close)
    currentWorth = startCurrency + startAssets * currentPrice

    storage.initialWorth ?= currentWorth
    storage.initialPrice ?= currentPrice

    rsi = talib.RSI
        inReal: i.close
        startIdx: 0
        endIdx: i.close.length - 1
        optInTimePeriod: 13

    rsi_P = talib.SMA
        inReal: rsi
        startIdx: 0
        endIdx: rsi.length - 1
        optInTimePeriod: 2

    rsi_T = talib.SMA
        inReal: rsi
        startIdx: 0
        endIdx: rsi.length - 1
        optInTimePeriod: 7

    results = talib.BBANDS
        inReal: rsi
        startIdx: 0
        endIdx: rsi.length-1
        optInTimePeriod: 34
        optInNbDevUp: 1.6185
        optInNbDevDn: 1.6185
        optInMAType: 0

    uB = results.outRealUpperBand
    mB = results.outRealMiddleBand
    lB = results.outRealLowerBand

    botPL = ((currentWorth - storage.initialWorth)/storage.initialWorth) * 100
    marketPL = ((currentPrice - storage.initialPrice)/storage.initialPrice) * 100

#buy seq
    if !storage.bought and 
        currentCurrency = startCurrency
        currentAssets = startAssets

        totalCurrencyToSpend = startCurrency * (PCT_OF_FUNDS/100)
        split = (totalCurrencyToSpend * (PCT_OF_SPLIT/100))

        if (split < minimumCurrency)
            split = totalCurrencyToSpend

        amountRemaining = totalCurrencyToSpend
        infLoop = 0
        while (infLoop++ < 100 and amountRemaining >= minimumCurrency)
            startingCurrency = @portfolio.positions[i.curr()].amount
            startingAssets = @portfolio.positions[i.asset()].amount

            ticker = trading.getTicker(i)
            buyAmount = Math.min((split/ticker.buy)*.9975, amountRemaining/ticker.buy)
            try
                trading.buy i, 'market', buyAmount
            catch error
                if (/insufficient funds/i.exec(error))
                    currentCurrency = startingCurrency
                    currentAssets = startingAssets
                    break

            sleep(30000)
            i.update
            currentCurrency = @portfolio.positions[i.curr()].amount
            currentAssets = @portfolio.positions[i.asset()].amount
            currencyDelta = (startingCurrency - currentCurrency)
            if (currencyDelta != 0)
                assetDelta = (currentAssets - startingAssets)
                salePrice = (currencyDelta/assetDelta)
                info "Bought #{assetDelta.toFixed(8)} #{i._pair[0].toUpperCase()} at #{salePrice.toFixed(8)} #{i._pair[1].toUpperCase()}"
            amountRemaining -= currencyDelta

        totalBought = (currentAssets - startAssets)
        currencySpent = (startCurrency - currentCurrency)
        salePrice = currencySpent/totalBought
        info "Bought a total of #{totalBought.toFixed(8)} #{i._pair[0].toUpperCase()} at #{salePrice.toFixed(8)} #{i._pair[1].toUpperCase()}"
        info "Finished Buying!"
        storage.sold = false
        storage.bought = true
        storage.consecutiveBuySignals = 0
        storage.consecutiveSellSignals = 0
        storage.lastBuyPrice = salePrice
        storage.buys++

        plotMark
            bought: salePrice
else if (fisher < storage.lastFisher)
    storage.consecutiveSellSignals += 1
    storage.consecutiveBuySignals = 0
    plotMark
        bears: -1
#info log
    info "---------- DTI BOT ----------"
    info "Current Price: #{currentPrice.toFixed(8)} #{i._pair[1].toUpperCase()}"
    info "Exchange Wallet: #{startCurrency.toFixed(8)} #{i._pair[1].toUpperCase()} and #{startAssets.toFixed(8)} #{i._pair[0].toUpperCase()}"
    info "Start Worth: #{storage.initialWorth.toFixed(8)} #{i._pair[1].toUpperCase()} or #{(storage.initialWorth/storage.initialPrice).toFixed(8)} #{i._pair[0].toUpperCase()}"
    info "Current Worth: #{currentWorth.toFixed(8)} #{i._pair[1].toUpperCase()} or #{(currentWorth/currentPrice).toFixed(8)} #{i._pair[0].toUpperCase()}"
    if (botPL >= 0)
        info "Bot P/L: #{botPL.toFixed(2)}%"
    else
        warn "Bot P/L: #{botPL.toFixed(2)}%"

    if (marketPL >= 0)
        info "Buy&Hold P/L: #{marketPL.toFixed(2)}%"
    else
        warn "Buy&Hold P/L: #{marketPL.toFixed(2)}%"

    if (storage.sold)
        info "Currently Sold"
    if (storage.bought)
        info "Currently Bought"     
    info "Buys: #{storage.buys} Sells: #{storage.sells} Total Orders: #{storage.buys + storage.sells}"
    info "Wins: #{storage.wins} Losses: #{storage.losses} Total Trades: #{storage.wins + storage.losses}"
    info " "
#plots
    plot
        "PRICE LINE": _.last(rsi_P)          
    plot
        "TRADE LINE": _.last(rsi_T)
    plot
        "TOP V-BAND": _.last(uB)
    plot
        "MID V-BAND": _.last(lB) 
    plot
        "BOTTOM V-BAND": _.last(mB) 
